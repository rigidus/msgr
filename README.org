#+TITLE: MSGR - Secure Messenger
#+AUTHOR: Rigidus<i.am.rigidus@gmail.com

* Введение

Это минималистичный мессенджер, с шифрованием сообщений для сборки и работы на Linux и macOS.

Он состоит из нескольких приложений, которые должны быть запущены вместе (например в chroot), так как они взаимодействуют друг с другом через файлы.

Рассчитан на то чтобы быть максимально простым но при этом расширяемым.

* Схема работы
#+CAPTION: Архитектура мессенджера
[[file:doc/img/components.png]]

Сообщения проходят цепочку:

#+BEGIN_EXAMPLE
ui_in_msg → msgs/ → cryptor → encrypted_msgs/ → communicator → сеть
сеть → communicator → encrypted_msgs/ → cryptor → msgs/ → ui_out_msg
#+END_EXAMPLE

* Состав проекта
** Каталоги
- =msgs/= :: «чистые» сообщения пользователя.
- =encrypted_msgs/= :: зашифрованные сообщения, готовые к отправке или полученные из сети.
- =keys/= ::
  - =me_private.pem= — приватный ключ RSA-4096.
  - =peer_public.pem= — публичный ключ собеседника.

** Формат файлов
*** Открытые сообщения (=msgs/=)
#+BEGIN_SRC lisp
(msg
  :id "01J9H2..."
  :prev-id "01J9H1..."
  :time "2025-09-16T20:00:00.123Z"
  :dir "in"|"out"
  :data "Привет, мир")
#+END_SRC
Ограничение: плейнтекст ≤ 446 байт.

*** Зашифрованные (=encrypted_msgs/=)
#+BEGIN_SRC lisp
(emsg
  :id "01J9H2..."
  :dir "in"|"out"
  :cipher "BASE64_RSA_CIPHERTEXT")
#+END_SRC
=:cipher= всегда длиной 512 байт после base64-декодирования.

** Бинарники
- =ui_in_msg= :: ввод сообщений пользователем.
- =ui_out_msg= :: вывод входящих сообщений.
- =cryptor= :: шифрование/дешифрование между =msgs/= и =encrypted_msgs/=.
- =communicator= :: передача зашифрованных сообщений в сеть (MVP: заглушка).

* Сборка
Требуется =gcc= или =clang=, поддержка POSIX API и OpenSSL (для =cryptor=).

#+BEGIN_SRC sh
# собрать все бинарники
make

# или по отдельности
make ui_in_msg
make ui_out_msg
make cryptor
make communicator
#+END_SRC

* Запуск

Каждый бинарник запускается отдельным процессом и работает в бесконечном
цикле, опрашивая каталоги раз в секунду.

#+BEGIN_SRC sh
  # 1. Запуск ввода сообщений
  # принимает сообщения от пользователя
  ./ui_in_msg

  # 2. Запуск вывода сообщений
  # Показывает пользователю последние сообщения
  ./ui_out_msg

  # 3. Шифратор
  # выполняет шифрование исходящих, и расшифровку входящих сообщений
  ./cryptor

  # 4. Коммуникатор
  # выполняет отправку, и приём зашифрованных сообщений
  ./communicator
#+END_SRC

** Сгенерировать ключи для криптора
Приватный ключ (PKCS#8 PEM)

#+BEGIN_SRC sh
openssl genrsa -out keys/me_private.pem 4096
#+END_SRC

Публичный ключ собеседника (для теста можно взять свою же пару)
#+BEGIN_SRC sh
openssl rsa -in keys/me_private.pem -pubout -out keys/peer_public.pem
#+END_SRC

* Шаблон цикла сообщений с таймаутом

Каждое из приложений проекта использует единый шаблон: бесконечный цикл на основе =select(2)= с таймером. Он решает две задачи:
1) гарантирует выполнение «работы по таймеру» ровно раз в секунду (опрос каталогов, шифрование, отправка/приём и т.д.),
2) не блокирует процесс на вводе/выводе: даже если нет данных на =stdin=, в сокете или пайпе, таймер всё равно сработает.

** Как это работает
- Внутренний =event loop= вызывает =select(2)= с таймаутом =1s= на наборе файловых дескрипторов (FD): =stdin=, сокеты/пайпы (если есть).
- Если за секунду пришли данные на каком-либо FD — вызывается соответствующий обработчик (=on_readable=).
- Если за секунду ничего не пришло — срабатывает =on_timer= (процедура опроса каталога/обработки задач).
- Таймер точный: если обработка заняла дольше 1s, цикл «догоняет» пропущенные тики, вызывая =on_timer= несколько раз подряд до выравнивания дедлайна.

** Файлы шаблона
- =event_loop.h/.c= — кроссплатформенная обёртка вокруг =select(2)=:
  - регистрация FD на «чтение»,
  - колбэк таймера (=on_timer=),
  - обработка сигналов SIGINT/SIGTERM (мягкая остановка).

** Где писать свой код
- В каждом приложении определяются два (иногда один) колбэка:
  - =on_timer(void*)= — периодическая работа 1 раз в секунду,
  - =on_readable(int fd, void*)= — реакция на готовность FD (нужен не всегда).

** Минимальный код с использованием шаблона
#+BEGIN_SRC c
#include "event_loop.h"
#include "common.h"

/* 1) Периодическая работа (каждую секунду) */
static void on_timer(void *ud) {
  (void)ud;
  /* пример для cryptor:
     - encrypt_pass();  // msg:out -> emsg:out -> delete msg
     - decrypt_pass();  // emsg:in -> msg:in -> delete emsg
   */
}

/* 2) Обработчик готовности дескриптора (опционально) */
static void on_stdin(int fd, void *ud) {
  (void)ud;
  char line[4096];
  ssize_t n = read(fd, line, sizeof(line)-1);
  if (n > 0) {
    line[n] = '\0';
    /* пример для ui_in_msg:
       - build_msg_expr(line, /*dir=*/"out", /*id/time/...*/);
       - insert_new(/*type=*/"msg", /*sexpr_str*/);
     */
  }
}

int main(void) {
  event_loop *el = el_create(/*interval_ms=*/1000, on_timer, NULL);

  /* Регистрируем stdin, если бинарнику нужен интерактивный ввод */
  /* el_add_fd(el, STDIN_FILENO, on_stdin, NULL); */

  int rc = el_run(el);
  el_destroy(el);
  return rc;
}
#+END_SRC

** Рекомендации по использованию шаблона
- *Не блокируйтесь* внутри колбэков: все долгие операции разбивайте на шаги, выполняемые в последовательных тиках.
- Любая запись файла делается через безопасную последовательность:
  1) запись во временный файл в том же каталоге,
  2) =fsync()= на дескриптор,
  3) атомарный =rename()= в целевое имя.
- Чтение каталога — сортировка по имени (оно уже кодирует время) для стабильного порядка.
- Сетевые библиотеки подключаются *только* в =communicator=; OpenSSL — *только* в =cryptor=.
- Все строки — UTF-8; S-expression в формате plist; никаких расширений файлов и маркеров не используется.
- Параллельные процессы не предполагаются: каждый бинарник — один процесс, один event loop.

** Как добавить новую периодическую задачу
1) Определите функцию (например, =reap_temp_files()=).
2) Вставьте вызов в =on_timer()= соответствующего бинарника.
3) Если задача зависит от времени, храните её «следующий дедлайн» в статике или в =ud= (user-data) структуры.
4) Для общения между процессами используйте только файлы в =msgs/= и =encrypted_msgs/= по оговорённым форматам.
